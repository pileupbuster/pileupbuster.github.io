# üåê **Pileup Buster WebSocket API - Complete Reference**

**Document Version**: 1.0  
**Last Updated**: July 23, 2025  
**Target Audience**: Developers, External Software Integration (Qt6, C++, Python, etc.)

---

## üìã **Table of Contents**

1. [Overview & Architecture](#overview--architecture)
2. [Connection & Authentication](#connection--authentication)
3. [Message Protocol Structure](#message-protocol-structure)
4. [Public Operations](#public-operations)
5. [Admin Operations](#admin-operations)
6. [Real-time Events & Broadcasting](#real-time-events--broadcasting)
7. [Error Handling](#error-handling)
8. [Integration Examples](#integration-examples)
9. [Security & Best Practices](#security--best-practices)
10. [Troubleshooting Guide](#troubleshooting-guide)

---

## üèóÔ∏è **Overview & Architecture**

### **WebSocket Endpoint**
```
ws://localhost:8000/api/ws
```

### **Purpose**
The Pileup Buster WebSocket API provides a real-time, bidirectional communication channel for external logging software (like Qt6 applications) to:
- Manage amateur radio pileup queues
- Send QSO (contact) data to the system
- Control system activation/deactivation
- Receive real-time updates about queue changes and QSO status

### **Key Benefits**
- **Pure WebSocket Protocol**: No HTTP mixing required
- **Real-time Synchronization**: Immediate updates across all connected clients
- **Comprehensive Coverage**: All admin functions available via WebSocket
- **Robust Authentication**: Secure session-based token system
- **External Integration Ready**: Designed specifically for logging software integration

### **Protocol Design**
- **Message Format**: JSON-based communication
- **Authentication**: Session-based tokens with 24-hour expiry
- **Request/Response Pattern**: Each request has a `request_id` for correlation
- **Broadcasting**: Real-time updates sent to all connected clients
- **Error Handling**: Detailed error codes and descriptive messages

---

## üîê **Connection & Authentication**

### **Step 1: Establish WebSocket Connection**

**Endpoint**: `ws://localhost:8000/api/ws`

```javascript
// JavaScript Example
const websocket = new WebSocket('ws://localhost:8000/api/ws');

// C++ Qt6 Example
QWebSocket *webSocket = new QWebSocket();
webSocket->open(QUrl("ws://localhost:8000/api/ws"));
```

### **Step 2: Authenticate**

**Message Type**: `auth_request`

**Request Format**:
```json
{
  "type": "auth_request",
  "request_id": "auth_001",
  "username": "admin",
  "password": "your_password"
}
```

**Success Response**:
```json
{
  "type": "auth_response",
  "request_id": "auth_001",
  "success": true,
  "session_token": "abc123def456ghi789jkl012mno345pqr678stu901vwx234yz",
  "expires_at": "2025-07-23T12:00:00Z",
  "message": "Authentication successful"
}
```

**Error Response**:
```json
{
  "type": "error",
  "request_id": "auth_001",
  "error_code": "INVALID_CREDENTIALS",
  "message": "Invalid username or password"
}
```

### **Step 3: Store Session Token**
Save the `session_token` for use in all subsequent admin operations. Tokens expire after 24 hours.

---

## üì® **Message Protocol Structure**

### **Request Message Format**
```json
{
  "type": "message_type",           // Required: Operation to perform
  "request_id": "unique_id",        // Required: Unique identifier for correlation
  "session_token": "token_here",    // Required for admin operations
  // Additional fields specific to each operation
}
```

### **Success Response Format**
```json
{
  "type": "success",
  "request_id": "unique_id",        // Matches the request
  "message": "Operation successful",
  "data": {                         // Optional: Additional response data
    // Operation-specific data
  }
}
```

### **Error Response Format**
```json
{
  "type": "error",
  "request_id": "unique_id",        // Matches the request
  "error_code": "ERROR_TYPE",       // Standardized error code
  "message": "Detailed error description"
}
```

### **Broadcast Message Format**
```json
{
  "type": "broadcast_type",         // Type of broadcast event
  "timestamp": "2025-07-23T12:00:00Z",
  "data": {
    // Event-specific data
  }
}
```

---

## üåç **Public Operations**

Public operations don't require authentication and can be used by any connected client.

### **1. Register Callsign in Queue**

**Purpose**: Add a callsign to the FIFO queue for pileup management

**Message Type**: `register_callsign`

**Request**:
```json
{
  "type": "register_callsign",
  "request_id": "reg_001",
  "callsign": "EA1ABC"
}
```

**Success Response**:
```json
{
  "type": "success",
  "request_id": "reg_001",
  "message": "Callsign registered successfully",
  "data": {
    "callsign": "EA1ABC",
    "position": 3,
    "total_queue": 3,
    "estimated_wait": "6 minutes",
    "qrz_data": {
      "name": "John Smith",
      "address": "Madrid, Spain",
      "dxcc_name": "Spain",
      "country": "Spain"
    }
  }
}
```

**Error Responses**:
```json
// Invalid callsign format
{
  "type": "error",
  "request_id": "reg_001",
  "error_code": "INVALID_CALLSIGN",
  "message": "Invalid callsign format: EA1ABC-INVALID"
}

// System inactive
{
  "type": "error",
  "request_id": "reg_001",
  "error_code": "SYSTEM_INACTIVE",
  "message": "Registration is currently disabled"
}

// Queue full
{
  "type": "error",
  "request_id": "reg_001",
  "error_code": "QUEUE_FULL",
  "message": "Queue is full (4/4). Please try again later."
}

// Already in queue
{
  "type": "error",
  "request_id": "reg_001",
  "error_code": "ALREADY_IN_QUEUE",
  "message": "Callsign EA1ABC is already in the queue"
}
```

### **2. Get Queue Status**

**Purpose**: Query current queue status and system information

**Message Type**: `get_queue_status`

**Request**:
```json
{
  "type": "get_queue_status",
  "request_id": "status_001"
}
```

**Success Response**:
```json
{
  "type": "success",
  "request_id": "status_001",
  "message": "Queue status retrieved successfully",
  "data": {
    "system_active": true,
    "registration_enabled": true,
    "queue_size": 2,
    "max_queue_size": 4,
    "queue": [
      {
        "callsign": "DL1ABC",
        "timestamp": "2025-07-22T10:30:00Z",
        "qrz": {
          "name": "Hans Mueller",
          "address": "Berlin, Germany",
          "dxcc_name": "Germany"
        }
      },
      {
        "callsign": "JA1XYZ",
        "timestamp": "2025-07-22T10:32:00Z",
        "qrz": {
          "name": "Hiroshi Tanaka",
          "address": "Tokyo, Japan",
          "dxcc_name": "Japan"
        }
      }
    ],
    "current_qso": {
      "callsign": "EA1ABC",
      "timestamp": "2025-07-23T10:28:00Z",
      "qrz": {
        "name": "John Smith",
        "address": "Madrid, Spain",
        "dxcc_name": "Spain"
      }
    }
  }
}
```

### **3. Get Current QSO**

**Purpose**: Query the currently active QSO

**Message Type**: `get_current_qso`

**Request**:
```json
{
  "type": "get_current_qso",
  "request_id": "current_001"
}
```

**Success Response**:
```json
{
  "type": "success",
  "request_id": "current_001",
  "message": "Current QSO retrieved",
  "data": {
    "current_qso": {
      "callsign": "EA1ABC",
      "timestamp": "2025-07-23T10:28:00Z",
      "qrz": {
        "name": "John Smith",
        "address": "Madrid, Spain",
        "dxcc_name": "Spain"
      }
    }
  }
}
```

---

## üîí **Admin Operations**

Admin operations require authentication with a valid session token.

### **1. Start QSO in Pileup Buster**

**Purpose**: Start a new QSO (contact) in the Pileup Buster system

**Message Type**: `admin_start_qso`

**Request**:
```json
{
  "type": "admin_start_qso",
  "request_id": "qso_001",
  "session_token": "your_session_token",
  "callsign": "EA1ABC",
  "frequency_mhz": 14.205,
  "mode": "USB",
  "source": "logging_software"
}
```

**Success Response**:
```json
{
  "type": "success",
  "request_id": "qso_001",
  "message": "QSO started successfully",
  "data": {
    "callsign": "EA1ABC",
    "frequency_mhz": 14.205,
    "mode": "USB",
    "source": "logging_software",
    "qrz_data": {
      "name": "John Smith",
      "address": "Madrid, Spain",
      "dxcc_name": "Spain"
    }
  }
}
```

### **2. Work Next User in Queue**

**Purpose**: Advance the queue by working the next person (FIFO order)

**Message Type**: `admin_work_next`

**Request**:
```json
{
  "type": "admin_work_next",
  "request_id": "work_001",
  "session_token": "your_session_token"
}
```

**Success Response**:
```json
{
  "type": "success",
  "request_id": "work_001",
  "message": "Next user activated for QSO",
  "data": {
    "callsign": "DL1ABC",
    "qrz_data": {
      "name": "Hans Mueller",
      "address": "Berlin, Germany",
      "dxcc_name": "Germany"
    },
    "queue_position": 1,
    "remaining_queue": 1
  }
}
```

**Error Response**:
```json
{
  "type": "error",
  "request_id": "work_001",
  "error_code": "QUEUE_EMPTY",
  "message": "No users in queue to work"
}
```

### **3. Work Specific Callsign from Queue**

**Purpose**: Work a specific callsign from the queue (removes from queue and sets as current QSO). If the callsign is already the current QSO, the operation succeeds without making changes.

**Message Type**: `admin_work_specific`

**Request**:
```json
{
  "type": "admin_work_specific",
  "request_id": "work_specific_001",
  "session_token": "your_session_token",
  "callsign": "JA1XYZ"
}
```

**Success Response (Taken from Queue)**:
```json
{
  "type": "success",
  "request_id": "work_specific_001",
  "message": "Now working JA1XYZ (taken from queue)",
  "data": {
    "current_qso": {
      "callsign": "JA1XYZ",
      "timestamp": "2025-07-23T14:30:00Z",
      "qrz": {
        "name": "Takeshi Yamamoto",
        "address": "Tokyo, Japan",
        "dxcc_name": "Japan"
      },
      "metadata": {
        "source": "queue_specific",
        "bridge_initiated": false,
        "original_position": 3
      }
    }
  }
}
```

**Success Response (Already Current QSO)**:
```json
{
  "type": "success",
  "request_id": "work_specific_001",
  "message": "Already working JA1XYZ (current QSO)",
  "data": {
    "current_qso": {
      "callsign": "JA1XYZ",
      "timestamp": "2025-07-23T14:25:00Z",
      "qrz": {
        "name": "Takeshi Yamamoto",
        "address": "Tokyo, Japan",
        "dxcc_name": "Japan"
      },
      "metadata": {
        "source": "queue_next",
        "bridge_initiated": false
      }
    }
  }
}
```

**Error Response**:
```json
{
  "type": "error",
  "request_id": "work_specific_001",
  "error_code": "INVALID_REQUEST",
  "message": "Callsign JA1XYZ not found in queue or current QSO"
}
```

### **4. Complete Current QSO**

**Purpose**: Mark the current QSO as complete without working the next user

**Message Type**: `admin_complete_qso`

**Request**:
```json
{
  "type": "admin_complete_qso",
  "request_id": "complete_001",
  "session_token": "your_session_token"
}
```

**Success Response**:
```json
{
  "type": "success",
  "request_id": "complete_001",
  "message": "Current QSO completed successfully",
  "data": {
    "completed_callsign": "EA1ABC",
    "completion_time": "2025-07-22T10:35:00Z",
    "current_qso_cleared": true
  }
}
```

### **5. Toggle System Status**

**Purpose**: Enable or disable the Pileup Buster system (automatic toggle)

**Message Type**: `admin_toggle_system`

**Request**:
```json
{
  "type": "admin_toggle_system",
  "request_id": "toggle_001",
  "session_token": "your_session_token"
}
```

**Success Response (System Activated)**:
```json
{
  "type": "success",
  "request_id": "toggle_001",
  "message": "System activated successfully",
  "data": {
    "system_active": true,
    "registration_enabled": true,
    "previous_state": false,
    "changed_by": "logging_software",
    "timestamp": "2025-07-22T10:30:00Z"
  }
}
```

**Success Response (System Deactivated)**:
```json
{
  "type": "success",
  "request_id": "toggle_001",
  "message": "System deactivated successfully",
  "data": {
    "system_active": false,
    "registration_enabled": false,
    "previous_state": true,
    "changed_by": "logging_software",
    "timestamp": "2025-07-23T10:30:00Z",
    "queue_cleared": true,
    "qso_cleared": true
  }
}
```

### **6. Set Frequency**

**Purpose**: Set the current operating frequency

**Message Type**: `admin_set_frequency`

**Request**:
```json
{
  "type": "admin_set_frequency",
  "request_id": "freq_001",
  "session_token": "your_session_token",
  "frequency_mhz": 14.205
}
```

**Success Response**:
```json
{
  "type": "success",
  "request_id": "freq_001",
  "message": "Frequency set successfully",
  "data": {
    "frequency_mhz": 14.205
  }
}
```

### **7. Clear Frequency**

**Purpose**: Clear the current operating frequency

**Message Type**: `admin_clear_frequency`

**Request**:
```json
{
  "type": "admin_clear_frequency",
  "request_id": "clear_freq_001",
  "session_token": "your_session_token"
}
```

**Success Response**:
```json
{
  "type": "success",
  "request_id": "clear_freq_001",
  "message": "Frequency cleared successfully"
}
```

### **8. Heartbeat/Ping**

**Purpose**: Keep connection alive and verify connectivity

**Message Type**: `ping`

**Request**:
```json
{
  "type": "ping",
  "request_id": "ping_001",
  "session_token": "your_session_token"
}
```

**Success Response**:
```json
{
  "type": "pong",
  "request_id": "ping_001",
  "timestamp": "2025-07-23T10:30:00Z",
  "server_time": "2025-07-23T10:30:00.123Z"
}
```

---

## üì° **Real-time Events & Broadcasting**

The WebSocket API automatically broadcasts events to all connected clients when system state changes occur.

### **1. Queue Update Event**

**Trigger**: When queue changes (new registration, user worked, queue cleared)

**Broadcast Message**:
```json
{
  "type": "queue_update",
  "timestamp": "2025-07-22T10:30:00Z",
  "data": {
    "queue": [
      {
        "callsign": "JA1XYZ",
        "timestamp": "2025-07-22T10:32:00Z",
        "qrz": {
          "name": "Hiroshi Tanaka",
          "address": "Tokyo, Japan",
          "dxcc_name": "Japan"
        }
      }
    ],
    "total": 1,
    "max_size": 4,
    "change_type": "user_worked",
    "affected_callsign": "DL1ABC"
  }
}
```

### **2. QSO Update Event**

**Trigger**: When current QSO changes (new QSO started, QSO completed)

**Broadcast Message**:
```json
{
  "type": "qso_update",
  "timestamp": "2025-07-22T10:30:00Z",
  "data": {
    "callsign": "EA1ABC",
    "qrz": {
      "name": "John Smith",
      "address": "Madrid, Spain",
      "dxcc_name": "Spain"
    },
    "started_at": "2025-07-22T10:30:00Z",
    "source": "logging_software",
    "change_type": "qso_started"
  }
}
```

### **3. System Status Update Event**

**Trigger**: When system is activated/deactivated

**Broadcast Message**:
```json
{
  "type": "system_status_update",
  "timestamp": "2025-07-22T10:30:00Z",
  "data": {
    "active": true,
    "registration_enabled": true,
    "changed_by": "admin",
    "reason": "System toggled via WebSocket"
  }
}
```

### **4. Welcome Message**

**Trigger**: When a new WebSocket client connects

**Broadcast Message**:
```json
{
  "type": "welcome",
  "timestamp": "2025-07-22T10:30:00Z",
  "data": {
    "server_version": "1.0.0",
    "api_version": "1.0",
    "connection_id": "conn_12345",
    "features": [
      "authentication",
      "admin_operations",
      "real_time_updates",
      "qso_management"
    ]
  }
}
```

---

## ‚ö†Ô∏è **Error Handling**

### **Standard Error Codes**

| Error Code | Description | Common Causes |
|------------|-------------|---------------|
| `AUTH_REQUIRED` | Valid session token required | Missing or invalid token |
| `INVALID_CREDENTIALS` | Login credentials invalid | Wrong username/password |
| `SESSION_EXPIRED` | Session token has expired | Token older than 24 hours |
| `INVALID_REQUEST` | Request format is invalid | Missing required fields |
| `CALLSIGN_INVALID` | Callsign format is invalid | Non-amateur radio callsign |
| `SYSTEM_INACTIVE` | System is currently disabled | Registration disabled |
| `QUEUE_FULL` | Queue has reached maximum size | Too many users waiting |
| `SYSTEM_ERROR` | Internal server error | Database/server issues |

### **Error Response Examples**

**Authentication Error**:
```json
{
  "type": "error",
  "request_id": "req_001",
  "error_code": "AUTH_REQUIRED",
  "message": "Valid session token required for admin operations"
}
```

**Validation Error**:
```json
{
  "type": "error",
  "request_id": "req_002",
  "error_code": "CALLSIGN_INVALID",
  "message": "Invalid callsign format. Must be valid amateur radio callsign.",
  "details": {
    "provided_callsign": "INVALID123",
    "expected_format": "e.g., EA1ABC, JA1XYZ, W1ABC"
  }
}
```

**System State Error**:
```json
{
  "type": "error",
  "request_id": "req_003",
  "error_code": "QUEUE_FULL",
  "message": "Queue is full (4/4). Please try again later.",
  "details": {
    "current_size": 4,
    "max_size": 4,
    "suggested_action": "Wait for current QSO to complete"
  }
}
```

---

## üí° **Integration Examples**

### **Qt6/C++ Integration Example**

```cpp
#include <QWebSocket>
#include <QJsonDocument>
#include <QJsonObject>
#include <QTimer>

class PileupBusterClient : public QObject {
    Q_OBJECT

private:
    QWebSocket *webSocket;
    QString sessionToken;
    QTimer *heartbeatTimer;

public slots:
    void connectToPileupBuster() {
        webSocket = new QWebSocket();
        connect(webSocket, &QWebSocket::connected, this, &PileupBusterClient::onConnected);
        connect(webSocket, &QWebSocket::textMessageReceived, this, &PileupBusterClient::onMessageReceived);
        webSocket->open(QUrl("ws://localhost:8000/api/ws"));
    }

    void onConnected() {
        qDebug() << "Connected to Pileup Buster WebSocket";
        authenticate("admin", "your_password");
    }

    void authenticate(const QString& username, const QString& password) {
        QJsonObject auth;
        auth["type"] = "auth_request";
        auth["request_id"] = QString("auth_%1").arg(QDateTime::currentMSecsSinceEpoch());
        auth["username"] = username;
        auth["password"] = password;
        
        sendMessage(auth);
    }

    void startQSO(const QString& callsign, const QString& frequency, const QString& mode) {
        QJsonObject qso;
        qso["type"] = "admin_start_qso";
        qso["request_id"] = QString("qso_%1").arg(QDateTime::currentMSecsSinceEpoch());
        qso["session_token"] = sessionToken;
        qso["callsign"] = callsign;
        qso["frequency_mhz"] = frequency.toDouble();
        qso["mode"] = mode;
        qso["source"] = "logging_software";
        
        sendMessage(qso);
    }

    void toggleSystemStatus() {
        QJsonObject toggle;
        toggle["type"] = "admin_toggle_system";
        toggle["request_id"] = QString("toggle_%1").arg(QDateTime::currentMSecsSinceEpoch());
        toggle["session_token"] = sessionToken;
        
        sendMessage(toggle);
    }

    void onMessageReceived(const QString& message) {
        QJsonDocument doc = QJsonDocument::fromJson(message.toUtf8());
        QJsonObject obj = doc.object();
        
        QString type = obj["type"].toString();
        QString requestId = obj["request_id"].toString();
        
        if (type == "auth_response") {
            bool success = obj["success"].toBool();
            if (success) {
                sessionToken = obj["session_token"].toString();
                qDebug() << "Authentication successful";
                startHeartbeat();
            } else {
                qDebug() << "Authentication failed:" << obj["message"].toString();
            }
        }
        else if (type == "success") {
            qDebug() << "Operation successful:" << obj["message"].toString();
        }
        else if (type == "error") {
            qDebug() << "Error:" << obj["error_code"].toString() << obj["message"].toString();
        }
        else if (type == "queue_update") {
            handleQueueUpdate(obj["data"].toObject());
        }
        else if (type == "qso_update") {
            handleQSOUpdate(obj["data"].toObject());
        }
        else if (type == "system_status_update") {
            handleSystemStatusUpdate(obj["data"].toObject());
        }
    }

private:
    void sendMessage(const QJsonObject& message) {
        QJsonDocument doc(message);
        webSocket->sendTextMessage(doc.toJson());
    }

    void startHeartbeat() {
        heartbeatTimer = new QTimer(this);
        connect(heartbeatTimer, &QTimer::timeout, this, &PileupBusterClient::sendHeartbeat);
        heartbeatTimer->start(30000); // Ping every 30 seconds
    }

    void sendHeartbeat() {
        QJsonObject ping;
        ping["type"] = "ping";
        ping["request_id"] = QString("ping_%1").arg(QDateTime::currentMSecsSinceEpoch());
        ping["session_token"] = sessionToken;
        sendMessage(ping);
    }

    void handleQueueUpdate(const QJsonObject& data) {
        int queueSize = data["total"].toInt();
        emit queueSizeChanged(queueSize);
        qDebug() << "Queue updated, size:" << queueSize;
    }

    void handleQSOUpdate(const QJsonObject& data) {
        QString callsign = data["callsign"].toString();
        emit currentQSOChanged(callsign);
        qDebug() << "Current QSO changed to:" << callsign;
    }

    void handleSystemStatusUpdate(const QJsonObject& data) {
        bool active = data["active"].toBool();
        emit systemStatusChanged(active);
        qDebug() << "System status changed to:" << (active ? "ACTIVE" : "INACTIVE");
    }

signals:
    void queueSizeChanged(int size);
    void currentQSOChanged(const QString& callsign);
    void systemStatusChanged(bool active);
};
```

### **Python Integration Example**

```python
import asyncio
import websockets
import json
import time
from typing import Dict, Any, Optional

class PileupBusterClient:
    def __init__(self):
        self.websocket = None
        self.session_token = None
        self.request_counter = 0
        
    async def connect(self, url: str = "ws://localhost:8000/api/ws"):
        """Connect to Pileup Buster WebSocket"""
        self.websocket = await websockets.connect(url)
        print("Connected to Pileup Buster WebSocket")
        
        # Start message handler
        asyncio.create_task(self.message_handler())
        
    async def authenticate(self, username: str, password: str) -> bool:
        """Authenticate with admin credentials"""
        request = {
            "type": "auth_request",
            "request_id": f"auth_{int(time.time() * 1000)}",
            "username": username,
            "password": password
        }
        
        response = await self.send_and_wait_response(request)
        
        if response.get("success"):
            self.session_token = response.get("session_token")
            print("Authentication successful")
            return True
        else:
            print(f"Authentication failed: {response.get('message')}")
            return False
            
    async def start_qso(self, callsign: str, frequency_mhz: float, mode: str) -> Dict[str, Any]:
        """Start QSO in Pileup Buster"""
        request = {
            "type": "admin_start_qso",
            "request_id": f"qso_{int(time.time() * 1000)}",
            "session_token": self.session_token,
            "callsign": callsign,
            "frequency_mhz": frequency_mhz,
            "mode": mode,
            "source": "logging_software"
        }
        
        return await self.send_and_wait_response(request)
        
    async def toggle_system(self) -> Dict[str, Any]:
        """Toggle system active/inactive status"""
        request = {
            "type": "admin_toggle_system",
            "request_id": f"toggle_{int(time.time() * 1000)}",
            "session_token": self.session_token
        }
        
        return await self.send_and_wait_response(request)
        
    async def get_queue_status(self) -> Dict[str, Any]:
        """Get current queue status"""
        request = {
            "type": "get_queue_status",
            "request_id": f"status_{int(time.time() * 1000)}"
        }
        
        return await self.send_and_wait_response(request)
        
    async def register_callsign(self, callsign: str) -> Dict[str, Any]:
        """Register a callsign in the queue"""
        request = {
            "type": "register_callsign",
            "request_id": f"reg_{int(time.time() * 1000)}",
            "callsign": callsign
        }
        
        return await self.send_and_wait_response(request)
        
    async def send_and_wait_response(self, request: Dict[str, Any], timeout: float = 10.0) -> Dict[str, Any]:
        """Send request and wait for response"""
        request_id = request["request_id"]
        
        # Send request
        await self.websocket.send(json.dumps(request))
        
        # Wait for response
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                message = await asyncio.wait_for(self.websocket.recv(), timeout=1.0)
                data = json.loads(message)
                
                if data.get("request_id") == request_id:
                    return data
                    
            except asyncio.TimeoutError:
                continue
                
        raise TimeoutError(f"No response received for request {request_id}")
        
    async def message_handler(self):
        """Handle incoming messages (broadcasts, etc.)"""
        try:
            async for message in self.websocket:
                data = json.loads(message)
                message_type = data.get("type")
                
                # Handle broadcast messages
                if message_type == "queue_update":
                    await self.handle_queue_update(data)
                elif message_type == "qso_update":
                    await self.handle_qso_update(data)
                elif message_type == "system_status_update":
                    await self.handle_system_status_update(data)
                elif message_type == "welcome":
                    print(f"Welcome message: {data}")
                    
        except websockets.exceptions.ConnectionClosed:
            print("WebSocket connection closed")
            
    async def handle_queue_update(self, data: Dict[str, Any]):
        """Handle queue update broadcasts"""
        queue_data = data.get("data", {})
        queue_size = queue_data.get("total", 0)
        print(f"Queue updated: {queue_size} users waiting")
        
    async def handle_qso_update(self, data: Dict[str, Any]):
        """Handle QSO update broadcasts"""
        qso_data = data.get("data", {})
        callsign = qso_data.get("callsign")
        if callsign:
            print(f"Current QSO: {callsign}")
        else:
            print("No current QSO")
            
    async def handle_system_status_update(self, data: Dict[str, Any]):
        """Handle system status broadcasts"""
        status_data = data.get("data", {})
        active = status_data.get("active")
        print(f"System status: {'ACTIVE' if active else 'INACTIVE'}")

# Usage Example
async def main():
    client = PileupBusterClient()
    
    try:
        # Connect and authenticate
        await client.connect()
        await client.authenticate("admin", "your_password")
        
        # Get current status
        status = await client.get_queue_status()
        print(f"Queue status: {status}")
        
        # Start a QSO
        qso_result = await client.start_qso("EA1ABC", 14.205, "USB")
        print(f"QSO result: {qso_result}")
        
        # Toggle system
        toggle_result = await client.toggle_system()
        print(f"Toggle result: {toggle_result}")
        
        # Keep connection alive
        await asyncio.sleep(3600)  # Run for 1 hour
        
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    asyncio.run(main())
```

---

## üîí **Security & Best Practices**

### **Authentication Security**
- **Session Tokens**: 24-hour expiry, cryptographically secure
- **Credential Storage**: Store credentials securely, never in plain text
- **Token Management**: Refresh tokens before expiry, handle authentication failures gracefully

### **Connection Management**
- **Heartbeat**: Implement ping/pong to detect connection issues
- **Reconnection**: Automatic reconnection with exponential backoff
- **Error Handling**: Graceful degradation when WebSocket is unavailable

### **Message Handling**
- **Request IDs**: Use unique, time-based identifiers
- **Timeout Handling**: Set reasonable timeouts for responses
- **Message Validation**: Validate all incoming messages

### **Rate Limiting**
- **Reasonable Frequency**: Don't spam the API with requests
- **Batch Operations**: Group multiple operations when possible
- **Respect Server Limits**: Handle rate limiting errors appropriately

### **Best Practices Code Example**

```cpp
class RobustPileupBusterClient {
private:
    static const int MAX_RECONNECT_ATTEMPTS = 5;
    static const int HEARTBEAT_INTERVAL_MS = 30000;
    static const int RESPONSE_TIMEOUT_MS = 10000;
    
    QWebSocket *webSocket;
    QString sessionToken;
    QTimer *heartbeatTimer;
    QTimer *reconnectTimer;
    int reconnectAttempts;
    QQueue<QJsonObject> pendingRequests;
    QMap<QString, std::function<void(QJsonObject)>> responseHandlers;
    
public:
    void connectWithRetry() {
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
            emit connectionFailed("Maximum reconnection attempts reached");
            return;
        }
        
        webSocket = new QWebSocket();
        connect(webSocket, &QWebSocket::connected, this, &RobustPileupBusterClient::onConnected);
        connect(webSocket, &QWebSocket::disconnected, this, &RobustPileupBusterClient::onDisconnected);
        
        webSocket->open(QUrl("ws://localhost:8000/api/ws"));
        reconnectAttempts++;
    }
    
    void sendWithTimeout(const QJsonObject& request, std::function<void(QJsonObject)> callback) {
        QString requestId = request["request_id"].toString();
        responseHandlers[requestId] = callback;
        
        // Set timeout for response
        QTimer::singleShot(RESPONSE_TIMEOUT_MS, [this, requestId]() {
            if (responseHandlers.contains(requestId)) {
                responseHandlers.remove(requestId);
                emit requestTimedOut(requestId);
            }
        });
        
        sendMessage(request);
    }
    
    void onDisconnected() {
        qDebug() << "WebSocket disconnected, attempting reconnection...";
        
        if (heartbeatTimer) {
            heartbeatTimer->stop();
        }
        
        // Exponential backoff
        int delay = qMin(1000 * qPow(2, reconnectAttempts), 30000);
        
        reconnectTimer = new QTimer(this);
        reconnectTimer->setSingleShot(true);
        connect(reconnectTimer, &QTimer::timeout, this, &RobustPileupBusterClient::connectWithRetry);
        reconnectTimer->start(delay);
    }
    
    void onConnected() {
        reconnectAttempts = 0;
        emit connected();
        
        // Re-authenticate if we have stored credentials
        if (!lastUsername.isEmpty() && !lastPassword.isEmpty()) {
            authenticate(lastUsername, lastPassword);
        }
    }
};
```

---

## üîß **Troubleshooting Guide**

### **Common Connection Issues**

**Problem**: `Connection refused`
```
Solution: Ensure Pileup Buster backend is running on localhost:8000
Check: curl http://localhost:8000/health
```

**Problem**: `Authentication failed`
```
Solution: Verify admin credentials in backend environment
Check: ADMIN_USERNAME and ADMIN_PASSWORD environment variables
```

**Problem**: `Session expired`
```
Solution: Re-authenticate to get new session token
Tokens expire after 24 hours
```

### **Common Message Issues**

**Problem**: `INVALID_REQUEST` errors
```
Solution: Ensure all required fields are present
Check: Message format matches documentation examples
Validate: JSON syntax is correct
```

**Problem**: `SYSTEM_INACTIVE` errors
```
Solution: Activate the system before registering users
Use: admin_toggle_system message to activate
```

**Problem**: No response to requests
```
Solution: Check request_id is unique
Verify: Session token is valid and included
Timeout: Implement request timeout handling
```

### **Performance Issues**

**Problem**: Slow response times
```
Check: Network latency to server
Monitor: Server resource usage
Optimize: Reduce message frequency
```

**Problem**: Connection drops frequently
```
Solution: Implement heartbeat mechanism
Use: ping/pong messages every 30 seconds
Handle: Automatic reconnection with backoff
```

### **Debug Mode Examples**

**JavaScript Debug Mode**:
```javascript
// Enable verbose logging
const debug = true;

websocket.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (debug) {
        console.log('Received:', data);
    }
    
    // Handle message...
};

websocket.send = (message) => {
    if (debug) {
        console.log('Sending:', JSON.parse(message));
    }
    
    WebSocket.prototype.send.call(websocket, message);
};
```

**C++ Debug Mode**:
```cpp
void PileupBusterClient::sendMessage(const QJsonObject& message) {
    if (debugMode) {
        qDebug() << "Sending:" << QJsonDocument(message).toJson();
    }
    
    webSocket->sendTextMessage(QJsonDocument(message).toJson());
}

void PileupBusterClient::onMessageReceived(const QString& message) {
    if (debugMode) {
        qDebug() << "Received:" << message;
    }
    
    // Process message...
}
```

---

## üìö **Additional Resources**

### **Related Documentation**
- [WebSocket API Documentation](docs/WEBSOCKET_API_DOCUMENTATION.md)
- [Qt6 Integration Guide](QT6_WEBSOCKET_IMPLEMENTATION_GUIDE.md)
- [Development Setup](docs/DEVELOPMENT.md)

### **Testing Tools**
- [WebSocket Test Client](test_websocket_client.py)
- [System Integration Tests](backend/tests/)
- [HTML Test Page](test_websocket.html)

### **Support & Contact**
- **Issues**: GitHub Issues on the repository
- **Documentation Updates**: Submit pull requests
- **Feature Requests**: Create GitHub issues with enhancement label

---

**Document End** - Last Updated: July 23, 2025
